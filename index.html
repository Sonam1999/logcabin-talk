<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>LogCabin - usage, operation, and internals</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">

    <style>

.reveal h1 {
  font-size: 2.4em;
}

.reveal h2 {
  font-size: 1.8em;
}

.reveal h1,
.reveal h2,
.reveal h3,
.reveal h4,
.reveal h5,
.reveal h6 {
  text-transform: none; /* was uppercase */
}

.flex {
  display: flex;
}

ul.small, span.small {
  font-size: .8em;
}
pre.small{
  font-size: .4em;
}

    </style>

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <div class="slides">


<section>
  <h1>LogCabin</h1>
  <h3>usage, operation, and internals</h3>
  <p>
    <small>
      Created by <a href="https://ongardie.net/diego/">Diego Ongaro</a> /
      <a href="https://twitter.com/ongardie">@ongardie</a>
    </small>
  </p>
</section>

<section data-markdown>
  <script type="text/template">
    # Usage overview

    - hierarchical key-value store (tree)
      - strongly typed
    - linearizability
    - conditions
    - timeouts
    - working directory
    - logcabin CLI
    - client library
    - client sessions
      - Implicit state machine command before any others
      - Used to provide linearizability or crash
  </script>
</section>

<section data-markdown>
  <script type="text/template">
    # Internals

    - Raft
      - Leader election
      - Log replication
    - Client interaction
      - Finding cluster
      - Retries
      - Read-only queries
      - Read-write commands (and write pipeline)
    - Disk
      - Logs
      - Snapshots
    - RPC

  </script>
</section>

<section data-markdown>
  <script type="text/template">
    # Operation

    - Bootstrapping
    - Changing membership
    - Upgrades
    - logcabinctl

  </script>
</section>

<section>
  <section>
    <h1>Bootstrapping (1)</h1>
    <p>Bootstrap initializes the very first server's log with a configuration entry made up of just itself.</p>
    <pre>
<b>Server1$ cat logcabin.conf</b>
serverId = 1
listenAddresses = 192.168.5.12
storagePath = storage
    </pre>
    <pre>
<b>Server1$ logcabind --config=logcabin.conf --bootstrap</b>
...
Server/RaftConsensus.cc:572 in setConfiguration(): Activating configuration 1:
prev_configuration {
  servers {
    server_id: 1
    addresses: "192.168.5.12"
  }
}

Server/Main.cc:346 in main(): Done bootstrapping configuration. Exiting.
...
    </pre>
  </section>

  <section>
    <h1>Bootstrapping (2)</h1>
    <p>The directory structure shows a single log segment with a single entry, and no snapshot.</p>
    <pre>
<b>Server1$ tree -sh --du -F storage</b>
storage
└── [ 16K]  server1/
    ├── [   0]  lock
    ├── [8.1K]  log/
    │   └── [4.1K]  Segmented-Binary/
    │       ├── [  51]  00000000000000000001-00000000000000000001
    │       ├── [  35]  metadata1
    │       └── [  35]  metadata2
    └── [4.0K]  snapshot/
    </pre>
  </section>

  <section>
    <h1>Bootstrapping (3)</h1>
    <p><code>logcabin-storage</code> dumps out the log.</p>
    <pre class="small">
<b>Server1$ logcabin-storage --config=logcabin.conf</b>
...
Storage/Tool.cc:255 in main(): Log contents start
Log:
metadata start: 
current_term: 1
voted_for: 0
end of metadata
startIndex: 1

Entry 1 start:
term: 1
type: CONFIGURATION
configuration {
  prev_configuration {
    servers {
      server_id: 1
      addresses: "192.168.5.12"
    }
  }
}
index: 1
cluster_time: 0
end of entry 1
Storage/Tool.cc:257 in main(): Log contents end
...
Storage/Tool.cc:260 in main(): Reading snapshot at storage/server1
Storage/Tool.cc:153 in readSnapshot(): Snapshot file not found in storage/server1/snapshot
    </pre>
  </section>
</section>

<section>
  <section>
    <h1>Adding cluster members (1)</h1>
    <p>First, let's start up the servers.</p>
     <pre>
<b>Server2$ cat logcabin.conf</b>
serverId = 2
listenAddresses = 192.168.5.13
storagePath = storage
    </pre>
     <pre>
<b>Server3$ cat logcabin.conf</b>
serverId = 3
listenAddresses = 192.168.5.14
storagePath = storage
    </pre>
    <pre>
<b>Server1$ logcabind --config=logcabin.conf --daemon --log=server1.log</b>
<b>Server2$ logcabind --config=logcabin.conf --daemon --log=server2.log</b>
<b>Server3$ logcabind --config=logcabin.conf --daemon --log=server3.log</b>
    </pre>
  </section>

  <section>
    <h1>Adding cluster members (2)</h1>
    <p>The first server gets to become leader of itself.</p>
    <pre class="small">
<b>$ logcabinctl --server=$SERVER1IP stats get</b>
...
server_id: 1
addresses: "192.168.5.12"
...
raft {
  current_term: 2
  <b>state: LEADER</b>
  commit_index: 6
  last_log_index: 6
  leader_id: 1
  voted_for: 1
  ...
  last_snapshot_index: 0
  last_snapshot_bytes: 0
  log_start_index: 1
  log_bytes: 679
  ...
  peer {
    server_id: 1
    addresses: "192.168.5.12"
    old_member: true
    new_member: false
    staging_member: false
    last_synced_index: 6
  }
}
...
    </pre>
  </section>

  <section>
    <h1>Adding cluster members (3)</h1>
     <p>Other servers just sit idle, since they don't have a configuration.</p>
    <pre class="small">
<b>$ logcabinctl --server=$SERVER2IP stats get</b>
...
server_id: 2
addresses: "192.168.5.13"
...
raft {
  current_term: 0
  <b>state: FOLLOWER</b>
  commit_index: 0
  last_log_index: 0
  <b>leader_id: 0</b>
  voted_for: 0
  ...
  last_snapshot_index: 0
  last_snapshot_bytes: 0
  log_start_index: 1
  log_bytes: 1
  ...
  peer {
    server_id: 2
    addresses: ""
    old_member: false
    new_member: false
    staging_member: false
  }
}
...
    </pre>
  </section>

  <section>
    <h1>Adding cluster members (4)</h1>
     <p>We can ask the leader to add the other two.</p>
    <pre>
<b>$ export CLUSTER=$SERVER1IP,$SERVER2IP,$SERVER3IP</b>
<b>$ logcabin-reconfigure --cluster=$CLUSTER set $SERVER1IP $SERVER2IP $SERVER3IP</b>
Current configuration:
Configuration 1:
- 1: 192.168.5.12

Attempting to change cluster membership to the following:
1: 192.168.5.12 (given as 192.168.5.12)
2: 192.168.5.13 (given as 192.168.5.13)
3: 192.168.5.14 (given as 192.168.5.14)

Membership change result: OK

Current configuration:
Configuration 11:
- 1: 192.168.5.12
- 2: 192.168.5.13
- 3: 192.168.5.14
    </pre>
  </section>

  <section>
    <h1>Adding cluster members (5)</h1>
     <p>Now servers 2 and 3 are part of the cluster, have the latest configuration, and are proper followers.</p>
    <pre class="small">
<b>$ logcabinctl --server=$SERVER2IP stats get</b>
...
raft {
  current_term: 17
  state: FOLLOWER
  commit_index: 1045
  last_log_index: 1045
  leader_id: 1
  voted_for: 0
  ...
  peer {
    server_id: 1
    addresses: "192.168.5.12"
    old_member: true
    new_member: false
    staging_member: false
  }
  peer {
    server_id: 2
    addresses: "192.168.5.13"
    old_member: true
    new_member: false
    staging_member: false
  }
  peer {
    server_id: 3
    addresses: "192.168.5.14"
    old_member: true
    new_member: false
    staging_member: false
  }
}
    </pre>
  </section>
</section>

<section>
  <section>
    <h1>Joint consensus (1)</h1>
    <p>LogCabin uses the <em>joint consensus</em> approach to Raft membership changes.</p>
    <ul>
      <li>Older form of membership changes, prior to single-server approach (see dissertation).</li>
      <li>Allows transitioning from one cluster to another arbitrarily (no need for overlap).</li>
      <li>Cluster remains available throughout.</li>
    </ul>
  </section>

  <section>
    <h1>Joint consensus (2)</h1>
    Procedure:
    <ol>
      <li>Leader catches up new servers with the latest snapshot and (most) log entries.</li>
      <li>Leader appends a transitional configuration entry to its log. Under this configuration, becoming leader and committing entries requires both:</li>
        <ul>
          <li>a majority of the old configuration, and</li>
          <li>a majority of the new configuration.</li>
        </ul>
      </li>
      <li>Leader commits transitional configuration entry.</li>
      <li>Leader appends new configuration entry to its log.</li>
      <li>Leader commits new configuration entry.</li>
  </section>

  <section>
    <h1>Joint consensus (3)</h1>
    <p>Log from adding servers after bootstrapping</p>
    <pre class="small">
<b>Server1$ cat server1.log</b>
...
Server/RaftConsensus.cc:1595 in setConfiguration(): Attempting to change the configuration from 1
Server/RaftConsensus.cc:1603 in setConfiguration(): Adding server 1 at 192.168.5.12 to staging servers
Server/RaftConsensus.cc:1603 in setConfiguration(): Adding server 2 at 192.168.5.13 to staging servers
Server/RaftConsensus.cc:1603 in setConfiguration(): Adding server 3 at 192.168.5.14 to staging servers
...
Server/RaftConsensus.cc:1625 in setConfiguration(): Done catching up servers
Server/RaftConsensus.cc:1650 in setConfiguration(): Writing transitional configuration entry
...
Server/RaftConsensus.cc:572 in setConfiguration(): Activating configuration 10:
prev_configuration {
  servers { server_id: 1, addresses: "192.168.5.12" }
}
next_configuration {
  servers { server_id: 1, addresses: "192.168.5.12" },
  servers { server_id: 2, addresses: "192.168.5.13" },
  servers { server_id: 3, addresses: "192.168.5.14" }
}
Server/RaftConsensus.cc:572 in setConfiguration(): Activating configuration 11:
prev_configuration {
  servers { server_id: 1, addresses: "192.168.5.12" },
  servers { server_id: 2, addresses: "192.168.5.13" },
  servers { server_id: 3, addresses: "192.168.5.14" }
}
...
    </pre>
  </section>

  <section>
    <h1>Joint consensus (4)</h1>
    <p>Arbitrary cluster changes</p>
    <pre class="small">
<b>$ logcabin-reconfigure --cluster=$CLUSTER set $SERVER1IP</b>
Current configuration:
Configuration 11:
- 1: 192.168.5.12
- 2: 192.168.5.13
- 3: 192.168.5.14

Attempting to change cluster membership to the following:
1: 192.168.5.12 (given as 192.168.5.12)

Membership change result: OK

Current configuration:
Configuration 2357:
- 1: 192.168.5.12

<b>$ logcabin-reconfigure --cluster=$CLUSTER set $SERVER2IP $SERVER3IP</b>
Current configuration:
Configuration 2357:
- 1: 192.168.5.12

Attempting to change cluster membership to the following:
2: 192.168.5.13 (given as 192.168.5.13)
3: 192.168.5.14 (given as 192.168.5.14)

<b>[...wait for leader election...]</b>
Membership change result: OK

Current configuration:
Configuration 2378:
- 2: 192.168.5.13
- 3: 192.168.5.14
    </pre>
  </section>

</section>

<section>
  <section>
    <h1>logcabinctl</h1>
    <pre>
<b>$ logcabinctl --help</b>
Inspect or modify the state of a single LogCabin server.
...
Commands:
  info get                     Print server ID and addresses.
  debug filename get           Print the server's debug log filename.
  debug filename set &lt;path&gt;    Change the server's debug log filename.
  debug policy get             Print the server's debug log policy.
  debug policy set &lt;value&gt;     Change the server's debug log policy.
  debug rotate                 Rotate the server's debug log file.
  snapshot inhibit get         Print the remaining time for which the server
                               was prevented from taking snapshots.
  snapshot inhibit set [&lt;time&gt;]  Abort the server's current snapshot if one is
                                 in progress, and disallow the server from
                                 starting automated snapshots for the given
                                 duration [default: 1week].
  snapshot inhibit clear       Allow the server to take snapshots normally.
  snapshot start               Begin taking a snapshot if none is in progress.
  snapshot stop                Abort the current snapshot if one is in
                               progress.
  snapshot restart             Abort the current snapshot if one is in
                               progress, then begin taking a new snapshot.
  stats get                    Print detailed server metrics.
  stats dump                   Write detailed server metrics to server's debug
                               log.
    </pre>
  </section>

  <section>
    <h1>Forcing a snapshot</h1>
    <pre>
<b>$ logcabinctl --server=$SERVER1IP stats get | grep bytes</b>
  last_snapshot_bytes: 0
  log_bytes: 744921
  open_segment_bytes: 744867
    </pre>
    <pre>
<b>$ logcabinctl --server=$SERVER1IP snapshot start</b>
    </pre>
...wait a second...
    <pre>
<b>$ logcabinctl --server=$SERVER1IP stats get | grep bytes</b>
  last_snapshot_bytes: 2785
  log_bytes: 1863
  open_segment_bytes: 1863
    </pre>
  </section>

  <section>
    <h1>Inhibiting snapshots</h1>
    <p><code>scqad</code> prevents automatic snapshots for one week after a test failure.</p>
    <pre>
<b>$ logcabinctl --server=$SERVER1IP snapshot inhibit set 1week</b>
<b>$ logcabinctl --server=$SERVER1IP snapshot inhibit get</b>
604795.121117807 s
    </pre>
    <p>Allows you to see more Raft log history with <code>logcabin-storage</code>.</p>

    <p>Undo:</p>
    <pre>
<b>$ logcabinctl --server=$SERVER1IP snapshot inhibit clear</b>
<b>$ logcabinctl --server=$SERVER1IP snapshot inhibit get</b>
0 ns
    </pre>
  </section>

  <section>
    <h1>Changing debug log verbosity</h1>
    <p>Change the server's verbosity at runtime</p>
    <pre>
<b>$ logcabinctl --server=$SERVER1IP debug policy get</b>
NOTICE
<b>$ logcabinctl --server=$SERVER1IP debug policy set \</b>
<b>  Server/RaftConsensus.cc@VERBOSE,Storage@WARNING,NOTICE</b>
    </pre>
    <pre class="small">
<b>Server1$ tail server1.log</b>
Server/RaftConsensus.cc:1393 in handleAppendEntries() VERBOSE: New commitIndex: 4997
Server/RaftConsensus.cc:2804 in setElectionTimer() VERBOSE: Will become candidate in 581 ms
...
    </pre>

    Clients have similar control with:
    <pre>
LogCabin::Client::Debug::setLogPolicy(
  LogCabin::Client::Debug::logPolicyFromString(
    "Client@VERBOSE,NOTICE"));
    </pre>
  </section>
</section>

<section data-markdown>
  <script type="text/template">
    # Development

    - Code layout
    - Examples of changes?
    - Adding a command to logcabinctl?
    - ServerStats
    - Development procedure
    - Testing strategy/tools

  </script>
</section>

<section>
  <section>
    <h1>Code walkthrough</h1>
    <img src="auto/directories.svg" class="stretch" />
  </section>

  <section data-transition="none">
    <h1>Core/</h1>
    <div class="flex">
      <div><img src="auto/directories-Core.svg" /></div>
      <div style="min-width: 50%; min-height: 100000px">
        <!-- giant min-height forces title to top of screen -->
        <ul>
          <li>Randomness</li>
          <li>Time</li>
          <li>Mutex, condition variable</li>
          <li>STL and string utilities</li>
          <li>Checksumming</li>
          <li>Debug logging</li>
          <li>Buffer</li>
          <li>Config file</li>
        </ul>
      </div>
    </div>
  </section>

  <section data-transition="none">
    <h1>Event/</h1>
    <div class="flex">
      <div><img src="auto/directories-Event.svg" /></div>
      <div style="min-width: 50%; min-height: 100000px">
        <!-- giant min-height forces title to top of screen -->
        <ul>
          <li>Event loop (epoll)</li>
          <li>Singals</li>
          <li>Timers</li>
          <li>File descriptors</li>
          <li>Event::Loop::Lock:
            <ul style="font-size: .8em">
              <li>block event loop thread in user-space outside of any handler</li>
              <li>used when removing monitored files</li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </section>

  <section data-transition="none">
    <h1>RPC/</h1>
    <div class="flex">
      <div><img src="auto/directories-RPC.svg" /></div>
      <div style="min-width: 50%; min-height: 100000px">
        <!-- giant min-height forces title to top of screen -->
        <ul>
          <li>Low-level framing protocol</li>
          <li>Application-level connection initiation timeout and heartbeats</li>
          <li>Higher-level RPC protocol</li>
          <li>Address: DNS resolution</li>
          <li>Service: RPC endpoint</li>
          <li>Thread dispatch for most services</li>
        </ul>
      </div>
    </div>
  </section>

  <section data-transition="none">
    <h1>Protocol/</h1>
    <div class="flex">
      <div><img src="auto/directories-Protocol.svg" /></div>
      <div style="min-width: 50%; min-height: 100000px">
        <!-- giant min-height forces title to top of screen -->
        <ul>
          <li>Mostly Protocol Buffer definitions for individual RPC types</li>
        </ul>
      </div>
    </div>
  </section>

  <section data-transition="none">
    <h1>Server/</h1>
    <div class="flex">
      <div><img src="auto/directories-Server.svg" /></div>
      <div style="min-width: 50%; min-height: 100000px">
        <!-- giant min-height forces title to top of screen -->
        <ul>
          <li>Raft implementation</li>
          <li>State machine (client sessions, forking)</li>
          <li>Daemon startup (Globals)</li>
        </ul>
      </div>
    </div>
  </section>

  <section data-transition="none">
    <h1>Storage/</h1>
    <div class="flex">
      <div><img src="auto/directories-Storage.svg" /></div>
      <div style="min-width: 50%; min-height: 100000px">
        <!-- giant min-height forces title to top of screen -->
        <ul>
          <li>In-memory and on-disk log</li>
          <li>Opens/closes snapshot files</li>
          <li>Filesystem layout</li>
          <li>Filesystem utilities</li>
        </ul>
      </div>
    </div>
  </section>

  <section data-transition="none">
    <h1>Tree/</h1>
    <div class="flex">
      <div><img src="auto/directories-Tree.svg" /></div>
      <div style="min-width: 50%; min-height: 100000px">
        <!-- giant min-height forces title to top of screen -->
        <ul>
          <li>Core data structure for clients</li>
          <li>ProtoBuf-to-method call layer</li>
        </ul>
      </div>
    </div>
  </section>

  <section data-transition="none">
    <h1>Client/</h1>
    <div class="flex">
      <div><img src="auto/directories-Client.svg" /></div>
      <div style="min-width: 50%; min-height: 100000px">
        <!-- giant min-height forces title to top of screen -->
        <ul>
          <li>Implementation of client library</li>
          <li>LeaderRPC: connect to leader</li>
          <li>MockClientImpl: in-memory Tree used for testing applications</li>
        </ul>
      </div>
    </div>
  </section>

  <section data-transition="none">
    <h1>Examples/</h1>
    <div class="flex">
      <div><img src="auto/directories-Examples.svg" /></div>
      <div style="min-width: 50%; min-height: 100000px">
        <!-- giant min-height forces title to top of screen -->
        <ul>
          <li><code>logcabin-reconfigure</code></li>
          <li><code>logcabin</code> CLI tool</li>
          <li>Hello world</li>
          <li>Benchmark</li>
        </ul>
      </div>
    </div>
  </section>
</section>

<section>
  <section data-markdown>
    <script type="text/template">
# SegmentedStorage

Goals:
  - Easy to deploy: run on top of filesystem
  - Safe: fsync/fdatasync
  - Efficient:
    - About 1 disk write for each batch of entries
    - Allow leader to queue disk writes to a background thread

Operations:
  - Read log entry (common for newer entries)
  - Append batch of log entries (common)
  - Truncate suffix of log (rare, must be exact)
  - Truncate prefix of log (rare, only needs to reclaim most space)
    </script>
  </section>

  <section>
    <h1>SegmentedStorage internals</h1>
    <div class="flex">
      <div style="min-width: 50%">
        <img src="segmentedstorage.svg" />
      </div>
      <div>
        <ul>
          <li><em>Segment</em>: about 8MB file where consecutive log entries are written</li>
          <li>About 3 <em>open segments</em> pre-allocated by background thread
          <li>New log entries appended to <em>head segment</em></li>
          <li><em>closed segments</em> are immutable</li>
        </ul>
      </div>
    </div>
  </section>

  <section data-markdown>
    <script type="text/template">
# SegmentedStorage recovery (boot)

- Read metadata files (there are exactly two)
  - Use latest one with valid checksum
- For a closed segment:
  - Read all entries specified in filename
  - PANIC if checksum failure or entries missing
- For an open segment:
  - Read one entry at a time until checksum failure or EOF
  - If rest of file isn't all 0s, issue warning and continue
    - Probably crashed while writing an un-ack-ed entry
    - Or maybe an ack-ed entry was corrupted (Byzantine)
  - Close the segment: truncate the end of the file, rename it
- PANIC if gap or duplicate in log indexes
- Does not detect missing entries at end of log (Byzantine)
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
# SegmentedStorage wishlist

- Truncate suffix could just append a special marker and not use <code>ftruncate</code>
  - Not a localized change
  - No evidence of a problem with <code>ftruncate</code> at this point
- Should not store all log entries in memory ([#106](https://github.com/logcabin/logcabin/issues/106))
  - Probably pretty easy with mmap
    </script>
  </section>

</section>

<section>
  <section data-markdown>
    <script type="text/template">
# RPC system

- Used for all communication (client-server and server-server)
- For every request, servers either send a reply or close the connection
- No ordering guarantees between RPCs
- Protocol stack:
  1. TCP/IP (non-blocking sockets)
  2. Request-response framing protocol
  3. RPC protocol
  4. RPC-defined Protocol Buffers
    </script>
  </section>


  <section data-markdown>
    <script type="text/template">
# Request-response framing protocol

- Adapts from TCP's byte stream to message-oriented
- Responses paired with requests by their message ID
- TCP still somewhat useful (over UDP):
   - Flow control, congestion control
   - Retransmission and ordering within a connection
- Messages transmitted in full
  - Fixed size limit to each message (about 1MB) to limit head-of-line blocking
- Special `PING` and `VERSION` messages
- <span class="small">`RPC::MessageSocket::Header`</span>:
  <ul class="small">
    <li>magic: 0xdaf4 (2 bytes)</li>
    <li>version: 1 (2 bytes)</li>
    <li>payload length (4 bytes)</li>
    <li>message ID (8 bytes)</li>
  </ul>
</div>
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
# RPC protocol

- Figure out where to route requests
- Each service has a different thread pool
- Service specific error intended things like `NOT_LEADER`
- <span class="small">`RPC::Protocol::RequestHeaderVersion1`</span>:
  <ul class="small">
    <li>version: 1 (1 byte)</li>
    <li>service: `CLIENT|RAFT|CONTROL` (2 bytes)</li>
    <li>serviceSpecificErrorVersion (1 byte)</li>
    <li>opCode (2 bytes)</li>
  </ul>
- <span class="small">`RPC::Protocol::ResponseHeaderVersion1`</span>:
  <ul class="small">
    <li>
      status: `OK|SERVICE_SPECIFIC_ERROR|INVALID_VERSION|`
              `INVALID_SERVICE|INVALID_REQUEST` (1 byte)
    </li>
  </ul>
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
# RPC-defined Protocol Buffers

- Serialization format: Google Protocol Buffers version 2 (stable)
- Example from `Protocol/ServerControl.proto` (`logcabinctl debug filename set <path>`):

```
/**
 * DebugFilenameSet RPC: Change the server's debug log filename.
 */
message DebugFilenameSet {
    message Request {
        optional string filename = 1;
    }
    message Response {
        /**
         * This field will be present if any error occurred and not present
         * otherwise.
         */
        optional string error = 1;
    }
}
```
    </script>
  </section>

  <section data-markdown>
    <script type="text/template">
# RPC wishlist: gRPC

protobuf3 and HTTP/2

Pros:
  - Easier to invoke from other languages
  - Less code to maintain, less LogCabin-specific knowledge
  - No need for message size limit (HTTP/2 can fragment each message)

Cons:
  - Still in alpha
  - Hard to roll out while maintaining compatibility
    </script>
  </section>

</section>


      </div> <!-- slides -->

    </div> <!-- reveal -->

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1024,
        height: 768,

        // Factor of the display size that should remain empty around the content
        margin: 0.03,

        dependencies: [
          // Interpret Markdown in <section> elements
          { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        ],
      });

    </script>

  </body>
</html>
